import Testing
import Foundation
import MLX
import MLXNN
import MLXRandom
@testable import RVCNativeFeature

/// NOTE: These tests require Metal support and should be run on an iOS simulator or device.
/// Running on macOS via `swift test` may fail with Metal initialization errors.
/// To run these tests:
///   - Build and test the iOS app target in Xcode
///   - Use an iOS simulator or physical device
///   - The tests will automatically skip if Metal is not available

/// MLX Parity Validation Tests
///
/// These tests validate that the iOS Swift/MLX implementation achieves numerical parity
/// with the Python MLX implementation (target: ≥0.98 correlation).
///
/// Test data is generated by running: python3 tools/export_ios_test_data.py
///
/// Expected test data files:
/// - ios_test_data/input_audio.npy - Input audio waveform
/// - ios_test_data/hubert_features.npy - Python HuBERT output
/// - ios_test_data/rmvpe_f0.npy - Python RMVPE F0 output
/// - ios_test_data/rmvpe_hidden.npy - Python RMVPE hidden states

// MARK: - Numpy Loader

/// Load a numpy .npy file and return as MLXArray
func loadNumpyArray(path: String) throws -> (MLXArray, [Int], String) {
    let data = try Data(contentsOf: URL(fileURLWithPath: path))

    // Parse numpy .npy format
    // Magic: \x93NUMPY
    guard data.count > 10 else {
        throw TestError.fileTooSmall
    }

    // Read header length (bytes 8-10, little-endian uint16)
    let headerLen = Int(data[8]) + Int(data[9]) * 256
    let headerStart = 10
    let headerEnd = headerStart + headerLen

    guard data.count > headerEnd else {
        throw TestError.invalidHeader
    }

    let headerData = data[headerStart..<headerEnd]
    let headerString = String(data: headerData, encoding: .utf8) ?? ""

    // Parse shape from header
    let shapePattern = "'shape': \\(([^)]+)\\)"
    let shapeRegex = try NSRegularExpression(pattern: shapePattern)
    let shapeMatches = shapeRegex.matches(in: headerString, range: NSRange(headerString.startIndex..., in: headerString))

    var shape: [Int] = []
    if let match = shapeMatches.first,
       let range = Range(match.range(at: 1), in: headerString) {
        let shapeStr = String(headerString[range])
        shape = shapeStr.split(separator: ",").compactMap { Int($0.trimmingCharacters(in: .whitespaces)) }
    }

    // Parse dtype
    let dtypePattern = "'descr': '([^']+)'"
    let dtypeRegex = try NSRegularExpression(pattern: dtypePattern)
    let dtypeMatches = dtypeRegex.matches(in: headerString, range: NSRange(headerString.startIndex..., in: headerString))

    var dtype = "<f4" // default float32
    if let match = dtypeMatches.first,
       let range = Range(match.range(at: 1), in: headerString) {
        dtype = String(headerString[range])
    }

    // Load data
    let dataStart = headerEnd
    let dataBytes = data[dataStart...]

    let array: MLXArray

    if dtype.contains("f8") {  // float64
        let floats = dataBytes.withUnsafeBytes { ptr in
            Array(ptr.bindMemory(to: Double.self))
        }
        array = MLXArray(floats.map { Float($0) }).reshaped(shape)
    } else if dtype.contains("f4") {  // float32
        let floats = dataBytes.withUnsafeBytes { ptr in
            Array(ptr.bindMemory(to: Float.self))
        }
        array = MLXArray(floats).reshaped(shape)
    } else {
        throw TestError.unsupportedDtype(dtype)
    }

    return (array, shape, dtype)
}

// MARK: - Metrics

/// Compute Pearson correlation coefficient between two arrays
func computeCorrelation(_ a: MLXArray, _ b: MLXArray) -> Float {
    let aflat = a.reshaped([-1])
    let bflat = b.reshaped([-1])

    let amean = MLX.mean(aflat)
    let bmean = MLX.mean(bflat)

    let anorm = aflat - amean
    let bnorm = bflat - bmean

    let num = MLX.sum(anorm * bnorm)
    let denom = MLX.sqrt(MLX.sum(anorm * anorm) * MLX.sum(bnorm * bnorm))

    return (num / denom).item(Float.self)
}

/// Compute Root Mean Square Error between two arrays
func computeRMSE(_ a: MLXArray, _ b: MLXArray) -> Float {
    let diff = a - b
    let mse = MLX.mean(diff * diff)
    return MLX.sqrt(mse).item(Float.self)
}

/// Compute Mean Absolute Error between two arrays
func computeMAE(_ a: MLXArray, _ b: MLXArray) -> Float {
    let diff = MLX.abs(a - b)
    return MLX.mean(diff).item(Float.self)
}

// MARK: - Test Errors

enum TestError: Error {
    case fileTooSmall
    case invalidHeader
    case unsupportedDtype(String)
    case testDataNotFound(String)
    case modelNotFound(String)
    case correlationBelowThreshold(Float, expected: Float)
}

// MARK: - Test Suite

@Suite("MLX Parity Validation")
struct MLXParityTests {

    // Use absolute paths from repository root
    let repoRoot = "/Users/mcruz/Developer/Retrieval-based-Voice-Conversion-MLX"
    var testDataDir: String { "\(repoRoot)/ios_test_data" }
    var assetsDir: String { "\(repoRoot)/Demos/iOS/RVCNative/RVCNativePackage/Sources/RVCNativeFeature/Assets" }

    /// Test data paths
    var inputAudioPath: String { "\(testDataDir)/input_audio.npy" }
    var hubertFeaturesPath: String { "\(testDataDir)/hubert_features.npy" }
    var rmvpeF0Path: String { "\(testDataDir)/rmvpe_f0.npy" }
    var rmvpeHiddenPath: String { "\(testDataDir)/rmvpe_hidden.npy" }

    /// Model paths
    var hubertModelPath: String { "\(assetsDir)/hubert_base.safetensors" }
    var rmvpeModelPath: String { "\(assetsDir)/rmvpe.safetensors" }

    // MARK: - HuBERT Validation

    @Test("HuBERT correlation ≥ 0.98", .enabled(if: FileManager.default.fileExists(atPath: "ios_test_data/hubert_features.npy")))
    func testHubertParity() throws {
        print("\n" + String(repeating: "=", count: 60))
        print("HuBERT Parity Validation")
        print(String(repeating: "=", count: 60))

        // Load Python reference outputs
        print("\nLoading Python reference outputs...")
        let (inputAudio, _, _) = try loadNumpyArray(path: inputAudioPath)
        print("✓ Loaded input audio: \(inputAudio.shape)")

        let (pythonHubert, _, _) = try loadNumpyArray(path: hubertFeaturesPath)
        print("✓ Loaded Python HuBERT features: \(pythonHubert.shape)")

        // Load HuBERT model
        print("\nLoading HuBERT model...")
        let config = HubertConfig()
        let hubertModel = HubertModel(config: config)

        guard FileManager.default.fileExists(atPath: hubertModelPath) else {
            throw TestError.modelNotFound(hubertModelPath)
        }

        let hubertURL = URL(fileURLWithPath: hubertModelPath)
        let hubertWeights = try MLX.loadArrays(url: hubertURL)
        print("✓ Loaded weights: \(hubertWeights.count) tensors")

        // Apply weights to model
        hubertModel.update(parameters: ModuleParameters.unflattened(hubertWeights))
        print("✓ Applied weights to model")

        // Run inference
        print("\nRunning HuBERT inference...")
        let swiftHubert = hubertModel(inputAudio)
        print("✓ Swift HuBERT output shape: \(swiftHubert.shape)")

        // Compute metrics
        print("\nComputing correlation metrics...")
        let correlation = computeCorrelation(pythonHubert, swiftHubert)
        let rmse = computeRMSE(pythonHubert, swiftHubert)
        let mae = computeMAE(pythonHubert, swiftHubert)

        print("\nResults:")
        print("  Correlation: \(String(format: "%.6f", correlation))")
        print("  RMSE:        \(String(format: "%.6f", rmse))")
        print("  MAE:         \(String(format: "%.6f", mae))")

        // Validation thresholds
        let targetCorrelation: Float = 0.98

        print("\nValidation:")
        if correlation >= targetCorrelation {
            print("  ✅ PASS - Correlation ≥ \(targetCorrelation)")
        } else {
            print("  ❌ FAIL - Correlation < \(targetCorrelation)")
        }

        print(String(repeating: "=", count: 60))

        // Assert correlation meets threshold
        #expect(correlation >= targetCorrelation,
                "HuBERT correlation \(correlation) below threshold \(targetCorrelation)")
    }

    // MARK: - RMVPE Validation

    @Test("RMVPE F0 correlation ≥ 0.98", .enabled(if: FileManager.default.fileExists(atPath: "ios_test_data/rmvpe_f0.npy")))
    func testRMVPEParity() throws {
        print("\n" + String(repeating: "=", count: 60))
        print("RMVPE Parity Validation")
        print(String(repeating: "=", count: 60))

        // Load Python reference outputs
        print("\nLoading Python reference outputs...")
        let (inputAudio, _, _) = try loadNumpyArray(path: inputAudioPath)
        print("✓ Loaded input audio: \(inputAudio.shape)")

        let (pythonF0, _, _) = try loadNumpyArray(path: rmvpeF0Path)
        print("✓ Loaded Python RMVPE F0: \(pythonF0.shape)")

        // Load RMVPE model
        print("\nLoading RMVPE model...")
        let rmvpeModel = RMVPE()

        guard FileManager.default.fileExists(atPath: rmvpeModelPath) else {
            throw TestError.modelNotFound(rmvpeModelPath)
        }

        let rmvpeURL = URL(fileURLWithPath: rmvpeModelPath)
        let rmvpeWeights = try MLX.loadArrays(url: rmvpeURL)
        print("✓ Loaded weights: \(rmvpeWeights.count) tensors")

        // Apply weights to model
        rmvpeModel.update(parameters: ModuleParameters.unflattened(rmvpeWeights))
        print("✓ Applied weights to model")

        // Run inference
        print("\nRunning RMVPE inference...")
        let swiftF0 = rmvpeModel.infer(audio: inputAudio, thred: 0.03)
        print("✓ Swift RMVPE F0 shape: \(swiftF0.shape)")

        // Flatten for comparison (remove trailing dimension if present)
        let pythonF0Flat = pythonF0.reshaped([-1])
        let swiftF0Flat = swiftF0.reshaped([-1])

        // Compute metrics
        print("\nComputing correlation metrics...")
        let correlation = computeCorrelation(pythonF0Flat, swiftF0Flat)
        let rmse = computeRMSE(pythonF0Flat, swiftF0Flat)
        let mae = computeMAE(pythonF0Flat, swiftF0Flat)

        // Compute F0 cents error for voiced frames
        let pythonArray = pythonF0Flat.asArray(Float.self)
        let swiftArray = swiftF0Flat.asArray(Float.self)

        var centsErrors: [Float] = []
        for (py, sw) in zip(pythonArray, swiftArray) {
            if py > 10.0 && sw > 10.0 {  // Only voiced frames
                let ratio = Double(sw) / Double(py)
                let centsError = Float(1200.0 * Foundation.log2(ratio))
                centsErrors.append(abs(centsError))
            }
        }

        let meanCentsError = centsErrors.reduce(0.0, +) / Float(centsErrors.count)

        print("\nResults:")
        print("  Correlation:   \(String(format: "%.6f", correlation))")
        print("  RMSE:          \(String(format: "%.6f", rmse))")
        print("  MAE:           \(String(format: "%.6f", mae))")
        print("  Cents Error:   \(String(format: "%.2f", meanCentsError)) cents (mean)")

        // Validation thresholds
        let targetCorrelation: Float = 0.98
        let targetCentsError: Float = 2.0

        print("\nValidation:")
        if correlation >= targetCorrelation {
            print("  ✅ PASS - Correlation ≥ \(targetCorrelation)")
        } else {
            print("  ❌ FAIL - Correlation < \(targetCorrelation)")
        }

        if meanCentsError < targetCentsError {
            print("  ✅ PASS - Cents error < \(targetCentsError) cents")
        } else {
            print("  ❌ FAIL - Cents error ≥ \(targetCentsError) cents")
        }

        print(String(repeating: "=", count: 60))

        // Assert metrics meet thresholds
        #expect(correlation >= targetCorrelation,
                "RMVPE correlation \(correlation) below threshold \(targetCorrelation)")
        #expect(meanCentsError < targetCentsError,
                "RMVPE cents error \(meanCentsError) above threshold \(targetCentsError)")
    }

    // MARK: - Component Summary

    @Test("Load all test data")
    func testLoadTestData() throws {
        print("\n" + String(repeating: "=", count: 60))
        print("Test Data Summary")
        print(String(repeating: "=", count: 60))

        // Check all test files exist
        let files = [
            ("Input Audio", inputAudioPath),
            ("HuBERT Features", hubertFeaturesPath),
            ("RMVPE F0", rmvpeF0Path),
            ("RMVPE Hidden", rmvpeHiddenPath)
        ]

        print("\nTest files:")
        for (name, path) in files {
            let exists = FileManager.default.fileExists(atPath: path)
            let status = exists ? "✓" : "✗"
            print("  \(status) \(name): \(path)")

            if exists {
                do {
                    let (_, shape, dtype) = try loadNumpyArray(path: path)
                    print("      Shape: \(shape), dtype: \(dtype)")
                } catch {
                    print("      Warning: Could not load array (Metal may not be available): \(error)")
                }
            }
        }

        // Check all model files exist
        let models = [
            ("HuBERT", hubertModelPath),
            ("RMVPE", rmvpeModelPath)
        ]

        print("\nModel files:")
        for (name, path) in models {
            let exists = FileManager.default.fileExists(atPath: path)
            let status = exists ? "✓" : "✗"
            print("  \(status) \(name): \(path)")

            if exists {
                let attrs = try FileManager.default.attributesOfItem(atPath: path)
                let size = attrs[.size] as? Int64 ?? 0
                let sizeMB = Float(size) / 1_000_000.0
                print("      Size: \(String(format: "%.1f", sizeMB)) MB")
            }
        }

        print(String(repeating: "=", count: 60))
    }
}
